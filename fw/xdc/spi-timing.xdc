
# AT25SL64 Data:

# clock low to output valid:
#    6ns   max (main data read), 7ns max everything else
#    1.5ns min (output hold)
# data input
#    setup: min 2ns
#    hold:  min 3ns
# CS:
#    setup: min 5ns
#    hold:  min 5ns
#    deselect time: min 100ns !

# FLASH SPI
create_generated_clock -name usrCClk -source [get_port ulpiClk] -multiply_by 1 [get_pins {*U_STARTUP/USRCCLKO}]
#create_generated_clock -name usrCClk -source [get_pins {*U_STARTUP/USRCCLKO}] -multiply_by 1 [get_pins {*U_STARTUP/USRCCLKO}]

set_clock_latency -min 0.5 [get_clocks usrCClk]
set_clock_latency -max 7.6 [get_clocks usrCClk]

set_output_delay -clock [get_clocks usrCClk]             -max  2.2 [get_ports spiMOSI]
set_output_delay -clock [get_clocks usrCClk] -add_delay  -min -3.1 [get_ports spiMOSI]

set_output_delay -clock [get_clocks usrCClk]             -max  5.1 [get_ports spiCSb]
set_output_delay -clock [get_clocks usrCClk] -add_delay  -min -5.1 [get_ports spiCSb]

set_input_delay  -clock [get_clocks usrCClk]             -min  1.6 [get_ports spiMISO] -clock_fall
set_input_delay  -clock [get_clocks usrCClk] -add_delay  -max  6.1 [get_ports spiMISO] -clock_fall

# Trying to run SPI at 1/2 the ulpi clock rate; note that under normal circumstances
# CS\ -> clock is 1/2 SPI clock cycle and thus no multicycle path.
set_multicycle_path 2 -setup -to   [get_clocks usrCClk] -through [get_ports spiMOSI]
set_multicycle_path 1 -hold -end  -to   [get_clocks usrCClk] -through [get_ports spiMOSI]

set_multicycle_path 2 -setup -from [get_clocks usrCClk] -through [get_ports spiMISO]
set_multicycle_path 1 -hold -end  -from [get_clocks usrCClk] -through [get_ports spiMISO]

# We can relax hold timing on CS since this is never changed while the SPI clock is ticking
set_multicycle_path 3 -hold  -to   [get_clocks usrCClk] -through [get_ports spiCSb]

# ADC SPI
create_generated_clock -name adcSClk -source [get_port ulpiClk] -multiply_by 1 [get_ports adcSClk]

set_output_delay -clock [get_clocks adcSClk]             -max 10.1 [get_ports adcSDIO]
set_output_delay -clock [get_clocks adcSClk] -add_delay  -min -0.0 [get_ports adcSDIO]

# there is also a 50ns limitation on the SCLK period! that should be covered by
# the 4 multicycle constraint below.
# Also, the CS is usually generated by a separate transfer (on USB) so the CS edges
# are well separated from SCLK
set_output_delay -clock [get_clocks adcSClk]             -max  10  [get_ports adcCSb ]
set_output_delay -clock [get_clocks adcSClk] -add_delay  -min -10  [get_ports adcCSb ]

set_input_delay  -clock [get_clocks adcSClk]             -max 10.1 [get_ports adcSDIO] -clock_fall
set_input_delay  -clock [get_clocks adcSClk] -add_delay  -min  0.0 [get_ports adcSDIO] -clock_fall

# PGA SPI
create_generated_clock -name pgaSClk -source [get_port ulpiClk] -multiply_by 1 [get_ports pgaSClk]

set_output_delay -clock [get_clocks pgaSClk]             -max 10.1 [get_ports pgaSDat]
# there is actually no hold time specified!
set_output_delay -clock [get_clocks pgaSClk] -add_delay  -min -10  [get_ports pgaSDat]

set_output_delay -clock [get_clocks pgaSClk]             -max 20.1 [get_ports pgaCSb*]
set_output_delay -clock [get_clocks pgaSClk] -add_delay  -min -10  [get_ports pgaCSb*]

# max bit-bang rate are 2 clock cycles; the BitBangIF has an internal delay of 1 clock cycle
# which limits the fastest bit-banged clock to 4 cycles
# Chip-select would probably be 1/2 a SPI clock cycle which means a smaller multicycle
# multiplier - this doesnt' pass timing, however. Since the software uses a dedicated
# transfer for CS this is fine; otherwise, additional delay may be introduced
# in software.
set_multicycle_path 4 -setup -to   [get_clocks adcSClk] -through [get_ports {adcSDIO}]
set_multicycle_path 3 -hold -end  -to   [get_clocks adcSClk] -through [get_ports {adcSDIO}]
# relax hold timing for CS (not changing while SCLK is ticking)
set_multicycle_path 2 -setup -to   [get_clocks adcSClk] -through [get_ports {adcCSb}]
set_multicycle_path 5 -hold  -to   [get_clocks adcSClk] -through [get_ports {adcCSb}]

set_multicycle_path 4 -setup -from [get_clocks adcSClk] -through [get_ports adcSDIO]
set_multicycle_path 3 -hold -end  -from [get_clocks adcSClk] -through [get_ports adcSDIO]

set_multicycle_path 4 -setup -to   [get_clocks pgaSClk] -through [get_ports {pgaSDat}]
set_multicycle_path 3 -hold -end  -to   [get_clocks pgaSClk] -through [get_ports {pgaSDat}]
# relax hold timing for CS (not changing while SCLK is ticking)
set_multicycle_path 2 -setup -to   [get_clocks pgaSClk] -through [get_ports {pgaCSb*}]
set_multicycle_path 5 -hold -end  -to   [get_clocks pgaSClk] -through [get_ports {pgaCSb*}]
